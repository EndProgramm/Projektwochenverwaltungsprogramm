Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\n# Autoren: Martin, Max, Vincent, Christoph, Lia; erstellt: 24.02.2020\r\n# Der Projektwochenmanager zum zuordnen aller Schüler zu Projekten\r\n\r\nimport csv, os, random, time\r\nimport sqlite3 as sqli\r\nfrom tkinter import *\r\nfrom tkinter import filedialog  # muss aus unbekannten Gründen extra importiert werden\r\nfrom tkinter.messagebox import *\r\nfrom tkinter.ttk import Treeview, Progressbar\r\n\r\n\r\nclass Model(object):\r\n    def __init__(self):\r\n        if not os.path.exists('pwvwp.db'):\r\n            self.dbAnlegen()\r\n\r\n    def dbAnlegen(self):\r\n        connection = sqli.connect('pwvwp.db')\r\n        cursor = connection.cursor()\r\n\r\n        # Tabellen erzeugen\r\n        sql = \"CREATE TABLE projekte(pID INTEGER PRIMARY KEY, pName TEXT, pJahrg INTEGER, pNum INTEGER, pMaxS INTEGER)\"\r\n        cursor.execute(sql)\r\n\r\n        sql = \"CREATE TABLE schueler(sID INTEGER PRIMARY KEY, sVName TEXT, sName TEXT, sJahrg INTEGER, sKla INTEGER, \" \\\r\n              \"sErst INTEGER, sZweit INTEGER, sDritt INTEGER, sZu INTEGER); \"\r\n        cursor.execute(sql)\r\n\r\n        print('Datenbank pwvwp.db mit Tabellen mitarbeiter und projekte angelegt.')\r\n        connection.commit()\r\n        connection.close()\r\n\r\n    def importCSV(self, slcsv, plcsv, delis, delip):  # sl = schuelerliste, pl = projektliste\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n\r\n        # importieren der slcsv Datei\r\n        file = open(slcsv, 'r')\r\n        read = csv.reader(file, delimiter=delis)\r\n        for row in read:\r\n            sql = \"SELECT COUNT(*) FROM schueler WHERE sName = '\" + row[0] + \"' AND sVName = '\" + row[\r\n                1] + \"' AND sJahrg = '\" + row[2] + \"';\"\r\n            cur.execute(sql)\r\n            test = cur.fetchall()\r\n            if not test[0][0]:\r\n                sql = \"INSERT INTO schueler(sName, sVName, sJahrg, sKla, sErst, sZweit, sDritt, sZu) VALUES('\" + row[\r\n                    0] + \"', '\" + row[1] + \"', '\" + row[2] + \"', '\" + row[3] + \"', '\" + row[4] + \"', '\" + row[\r\n                          5] + \"', '\" + row[6] + \"', NULL);\"\r\n                print(9)\r\n                cur.execute(sql)\r\n            else:\r\n                print('Eintrag bereits vorhanden!')\r\n\r\n        # importieren der plcsv Datei\r\n        file = open(plcsv, 'r')\r\n        read = csv.reader(file, delimiter=\";\")\r\n        for row in read:\r\n            print(99)\r\n            sql = \"SELECT COUNT(*) FROM projekte WHERE pName = '\" + row[0] + \"' AND pJahrg = '\" + row[1] + \"';\"\r\n            cur.execute(sql)\r\n            test = cur.fetchall()\r\n            if not test[0][0]:\r\n                sql = \"INSERT INTO projekte(pName, pJahrg, pNum, pMaxS) VALUES('\" + row[0] + \"', '\" + row[1] + \"', '\" + \\\r\n                      row[2] + \"', '\" + row[3] + \"');\"\r\n                cur.execute(sql)\r\n            else:\r\n                print('Eintrag bereits vorhanden!')\r\n        print('CSV-Dateien importiert!')\r\n\r\n        con.commit()\r\n        con.close()\r\n\r\n    def exportCSV(self, slcsv, plcsv, delimiter):\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n\r\n        # auslesen der datenbankliste schueler in eine CSV-Datei\r\n        slfile = csv.writer(slcsv, delimiter=delimiter, quoting=csv.QUOTE_NONE)\r\n        sql = \"SELECT * FROM schueler;\"\r\n        cur.execute(sql)\r\n        dboutput = cur.fetchall()\r\n        for spalte in dboutput:\r\n            spalte = list(spalte)\r\n            del spalte[0]\r\n            slfile.writerow(spalte)\r\n\r\n        # auslesen der datenbankliste projekte in eine CSV-Datei\r\n        plfile = csv.writer(plcsv, delimiter=delimiter, quoting=csv.QUOTE_NONE)\r\n        sql = \"SELECT * FROM schueler;\"\r\n        cur.execute(sql)\r\n        dboutput = cur.fetchall()\r\n        for spalte in dboutput:\r\n            plfile.writerow(spalte)\r\n\r\n        print('Die Ergebnisse wurden in zwei CSV-Dateien Ausgegeben! Die Trennzeichen sind \";\".')\r\n        con.close()\r\n\r\n    def zuordnen(self, wahl):\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n        jahrg = 4  # Jahrgang\r\n        while jahrg <= 11:\r\n            jahrg += 1\r\n            b = 1  # Projekt\r\n            sql = \"select max(pNum) FROM projekte WHERE '\" + str(\r\n                jahrg) + \"' like pJahrg;\"  # max Projektnummer wird ermittelt\r\n            cur.execute(sql)\r\n            x = cur.fetchall()  # max Projektnummer\r\n            xx = x[0][0]\r\n            if xx is None:\r\n                xx = 0\r\n            while b <= xx:\r\n                liste = []\r\n                sql = \"select max(sID) FROM schueler WHERE '\" + str(jahrg) + \"' like sJahrg and '\" + str(\r\n                    b) + \"' like \" + wahl + \" and sZu is NULL;\"  # max sID wird ermittelt\r\n                cur.execute(sql)\r\n                zz = cur.fetchall()\r\n                z = 0\r\n                if zz[0][0]:\r\n                    z = zz[0][0]\r\n                y = 0  # zaehler sID\r\n                while y <= z:\r\n                    sql = \"select sID FROM schueler WHERE '\" + str(\r\n                        jahrg) + \"' like sJahrg and sZu is NULL and '\" + str(\r\n                        b) + \"' like \" + wahl + \" and '\" + str(\r\n                        y) + \"' like sID;\"  # Ermittlung von Schülern in jahrg jahrgang und b erstwahl\r\n                    cur.execute(sql)\r\n                    f = cur.fetchall()\r\n                    if f:\r\n                        ff = f[0][0]\r\n                        liste.append(ff)\r\n                    y += 1\r\n                sql = \"select pMaxS FROM projekte WHERE '\" + str(jahrg) + \"' like pJahrg and '\" + str(\r\n                    b) + \"' like pNum;\"\r\n                cur.execute(sql)\r\n                maxanz0 = cur.fetchall()\r\n                if maxanz0:\r\n                    sql = \"select count(sID) FROM schueler WHERE '\" + str(jahrg) + \"' like sJahrg and '\" + str(\r\n                        b) + \"' like sZu;\"\r\n                    cur.execute(sql)\r\n                    maxanz1 = cur.fetchall()\r\n                    if maxanz1:\r\n                        maxanz = maxanz0[0][0] - maxanz1[0][0]\r\n                    else:\r\n                        maxanz = maxanz0[0][0]\r\n                else:\r\n                    maxanz = 0\r\n                if maxanz > 0:\r\n                    if len(liste) <= maxanz:\r\n                        m = 0  # zähler der schüler\r\n                        while m < len(liste):\r\n                            sql = \"update schueler set sZu='\" + str(b) + \"' where '\" + str(liste[m]) + \"'like sID;\"\r\n                            cur.execute(sql)\r\n                            m += 1\r\n                    else:\r\n                        m = 0  # zähler der schüler\r\n                        listeaus1 = random.choices(liste, k=maxanz)\r\n                        while m < maxanz:\r\n                            sql = \"update schueler set sZu='\" + str(b) + \"' where '\" + str(\r\n                                listeaus1[m]) + \"'like sID;\"\r\n                            cur.execute(sql)\r\n                            m += 1\r\n                b = b + 1\r\n        con.commit()\r\n        con.close()\r\n\r\n    def restzuordnung(self):\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n\r\n        jahrg = 4  # Jahrgang\r\n        while jahrg <= 11:\r\n            jahrg += 1\r\n            sql = \"select pNum from projekte WHERE '\" + str(jahrg) + \"' like pJahrg\"\r\n            cur.execute(sql)\r\n            projekte = cur.fetchall()\r\n            sql = \"select sID from schueler WHERE '\" + str(jahrg) + \"' like sJahrg and sZu is NULL\"\r\n            cur.execute(sql)\r\n            schuler = cur.fetchall()\r\n            while len(schuler) > 0 and len(projekte) > 0:\r\n                sql = \"select pMaxS from projekte WHERE '\" + str(jahrg) + \"' like pJahrg and '\" + str(\r\n                    projekte[0][0]) + \"' like pNum\"\r\n                cur.execute(sql)\r\n                maxanz0 = cur.fetchall()\r\n                if maxanz0:\r\n                    sql = \"select count(sID) from schueler WHERE '\" + str(jahrg) + \"' like sJahrg and '\" + str(\r\n                        projekte[0][0]) + \"' like sZu\"\r\n                    cur.execute(sql)\r\n                    maxanz1 = cur.fetchall()\r\n                    maxanz = maxanz0[0][0] - maxanz1[0][0]\r\n                    if maxanz <= 0:\r\n                        projekte.pop(0)\r\n                    else:\r\n                        sql = \"update schueler set sZu='\" + str(projekte[0][0]) + \"' where '\" + str(\r\n                            schuler[0][0]) + \"'like sID ;\"\r\n                        cur.execute(sql)\r\n                        schuler.pop(0)\r\n            if len(schuler) != 0 and len(projekte) == 0:\r\n                showwarning('Fehler', 'Im ' + str(jahrg) + '. Jahrgang gibt es mehr Schüler als Plätze in den Kursen.')\r\n\r\n        con.commit()\r\n        con.close()\r\n\r\n    def einfuegen(self, tabelle, spalten_namen_tuple, value_tuple):\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n        sql = \"SELECT count(*) FROM \" + tabelle + \" WHERE \"\r\n        for i, e in enumerate(value_tuple):\r\n            if i < len(value_tuple) - 1:\r\n                sql += spalten_namen_tuple[i] + \" = '\" + e + \"' AND \"\r\n            else:\r\n                sql += spalten_namen_tuple[i] + \" = '\" + e + \"';\"\r\n        cur.execute(sql)\r\n        erg = cur.fetchall()\r\n        if not erg[0][0]:\r\n            sql = \"INSERT INTO \" + tabelle + \"(\"\r\n            for i in range(len(spalten_namen_tuple)):\r\n                if i == len(spalten_namen_tuple) - 1:\r\n                    sql += spalten_namen_tuple[i] + \")\"\r\n                else:\r\n                    sql += spalten_namen_tuple[i] + \", \"\r\n            sql += \" VALUES('\"\r\n            for i in range(len(value_tuple)):\r\n                if i == len(value_tuple) - 1:\r\n                    sql += value_tuple[i] + \"');\"\r\n                else:\r\n                    sql += value_tuple[i] + \"', '\"\r\n            cur.execute(sql)\r\n        else:\r\n            showerror('Fehler', 'Schüler bereits vorhanden!')\r\n        con.commit()\r\n        con.close()\r\n\r\n    def ausgabe(self, tabelle):\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n\r\n        sql = \"SELECT * FROM \" + tabelle + \";\"\r\n        cur.execute(sql)\r\n        erg = cur.fetchall()\r\n\r\n        con.close()\r\n        return erg\r\n\r\n    def jahrgsuch(self, jahrgang):\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n\r\n        sql = \"SELECT * FROM schueler WHERE sJahrg LIKE '\" + str(\r\n            jahrgang) + \"'\"\r\n        cur.execute(sql)\r\n        erg = cur.fetchall()\r\n\r\n        con.close()\r\n        return erg\r\n\r\n    def ausfuhren(self, sql):\r\n        con = sqli.connect('pwvwp.db')\r\n        cur = con.cursor()\r\n\r\n        cur.execute(sql)\r\n        erg = cur.fetchall()\r\n\r\n        con.close()\r\n        return erg\r\n\r\n\r\nclass View(Tk):\r\n    def __init__(self, imp, exp, bee, j5, j6, j7, j8, j9, j10, j11, j12, ja, hin, zord, ande, a1, a2, a3, a4, a5, a6,\r\n                 a7):\r\n        Tk.__init__(self)\r\n        self.title(\"Projektwochenverwaltungsprogramm\")\r\n        self.geometry('800x285')\r\n        self.maxsize(800, 285)\r\n        self.minsize(800, 285)\r\n        # bestimmen der Callbacks\r\n        self.callback_imp = imp\r\n        self.callback_exp = exp\r\n        self.callback_bee = bee\r\n        self.radiocom = {'jahrg': [j5, j6, j7, j8, j9, j10, j11, j12, ja], 'ande': [a1, a2, a3, a4, a5, a6, a7]}\r\n        self.callback_zord = zord\r\n        self.callback_hin = hin\r\n        self.callback_ande = ande\r\n        self.names = {'schueler': (\"Vorname\", \"Nachname\", \"Jahrg\", \"Klasse\", \"Erst Wunsch\", \"Zweit Wunsch\",\r\n                                   \"Dritt Wunsch\"),\r\n                      'jahrg': ('5', '6', '7', '8', '9', '10', '11', '12', 'Alle')}\r\n        self.labels = {}\r\n        self.entrys = {}\r\n        self.buttons = {}\r\n        self.vars = {'jahrg': IntVar(), 'ande': IntVar()}\r\n        self.radios = {}\r\n        self.rahmen = {1: Frame(master=self), 2: Frame(master=self)}\r\n        self.rahmen.update({11: Frame(master=self.rahmen[1])})\r\n        self.fenster = {}\r\n\r\n        # erstellen des Menüs\r\n        self.menubar = Menu(self)\r\n        self.filemenu = Menu(self.menubar, tearoff=0)\r\n        self.filemenu.add_command(label=\"importieren\", command=self.callback_imp)\r\n        self.filemenu.add_command(label=\"exportieren\", command=self.callback_exp)\r\n        self.filemenu.add_separator()\r\n        self.filemenu.add_command(label=\"Beenden\", command=self.callback_bee)\r\n        self.menubar.add_cascade(label=\"Datei\", menu=self.filemenu)\r\n        self.fmenu = Menu(self.menubar, tearoff=0)\r\n        self.fmenu.add_command(label=\"hinzufügen\", command=self.schulerhin)\r\n        self.fmenu.add_command(label=\"ändern\", command=self.schuelerandern)\r\n        self.menubar.add_cascade(label=\"Schüler\", menu=self.fmenu)\r\n        self.config(menu=self.menubar)\r\n\r\n        for i in range(len(self.names['jahrg'])):\r\n            self.radios['jahrg-' + self.names['jahrg'][i]] = Radiobutton(self.rahmen[11], text=self.names['jahrg'][i],\r\n                                                                         variable=self.vars['jahrg'], value=i,\r\n                                                                         command=self.radiocom['jahrg'][i])\r\n            self.radios['jahrg-' + self.names['jahrg'][i]].pack(side=LEFT)\r\n        self.radios['jahrg-Alle'].select()\r\n\r\n        # Tabelle\r\n        self.scrollbar = Scrollbar(self.rahmen[2], orient=\"vertical\")\r\n        self.table = Treeview(self.rahmen[2], yscrollcommand=self.scrollbar.set)\r\n        self.scrollbar.pack(side=RIGHT, fill=Y)\r\n\r\n        self.rahmen[1].pack()\r\n        self.rahmen[2].pack(fill=X)\r\n        self.rahmen[11].pack(side=LEFT, fill=X)\r\n\r\n        self.buttons['zuordnen'] = Button(text=\"Zuordnen\", command=self.callback_zord)\r\n        self.buttons['zuordnen'].pack(fill=X, padx=4, pady=4)\r\n\r\n    def popup_textentry(self, text, call_ok, call_cancel):\r\n        self.fenster['popup'] = Tk()\r\n        self.fenster['popup'].title('Aktion erforderlich!')\r\n        self.fenster['popup'].geometry(\"300x125\")\r\n        self.fenster['popup'].resizable(0, 0)\r\n        self.labels['popup'] = Label(self.fenster['popup'], text=text, font=('Arial', 13), wraplength=275)\r\n        self.entrys['popup'] = Entry(self.fenster['popup'])\r\n        self.rahmen['popup'] = Frame(self.fenster['popup'])\r\n        self.buttons['popup_OK'] = Button(self.rahmen['popup'], text='Ok', command=call_ok, width=10)\r\n        self.buttons['popup_Cancel'] = Button(self.rahmen['popup'], text='Cancel', command=call_cancel, width=10)\r\n        self.labels['popup'].pack(fill=X)\r\n        self.entrys['popup'].pack(pady=15)\r\n        self.rahmen['popup'].pack()\r\n        self.buttons['popup_OK'].pack(side=LEFT)\r\n        self.buttons['popup_Cancel'].pack(side=LEFT)\r\n\r\n    def popup_Progressbar(self):\r\n        self.fenster['popup'] = Tk()\r\n        self.fenster['popup'].title('In Bearbeitung!')\r\n        self.fenster['popup'].resizable(0, 0)\r\n        self.labels['popup'] = Progressbar(self.fenster['popup'], orient='horizontal', length=250, mode='determinate')\r\n        self.labels['popup'].pack()\r\n\r\n    def schulerhin(self):\r\n        self.fenster['hin'] = Tk()\r\n        self.fenster['hin'].title(\"Neue Schüler\")\r\n        self.fenster['hin'].geometry('780x110')\r\n        for i in range(len(self.names['schueler'])):\r\n            self.labels[self.names['schueler'][i]] = Label(self.fenster['hin'], text=self.names['schueler'][i])\r\n            self.labels[self.names['schueler'][i]].place(x=10 + (110 * i), y=10, width=100)\r\n        for i in range(len(self.names['schueler'])):\r\n            self.entrys[i] = Entry(self.fenster['hin'])\r\n            self.entrys[i].place(x=10 + (110 * i), y=40, width=100)\r\n        self.buttons['hin'] = Button(self.fenster['hin'], text=\"Schüler hinzufügen\", command=self.callback_hin)\r\n        self.buttons['hin'].place(x=330, y=70, width=120, height=30)\r\n\r\n    def schuelerandern(self):\r\n        try:\r\n            self.fenster['ande'].destroy()\r\n        except:\r\n            pass\r\n        self.fenster.update({'ande': Tk()})\r\n        self.fenster['ande'].title(\"Schüler ändern\")\r\n        self.fenster['ande'].geometry('725x110')\r\n\r\n        self.rahmen['ande'] = Frame(self.fenster['ande'])\r\n\r\n        self.rahmen['ande_ID'] = Frame(self.rahmen['ande'])\r\n        self.labels['ande_idLab'] = Label(self.rahmen['ande_ID'], text=\"ID\")\r\n        self.labels['ande_idLab'].pack(fill=X, pady=2)\r\n        self.entrys['ande_Eid'] = Entry(self.rahmen['ande_ID'])\r\n        self.entrys['ande_Eid'].pack(side=LEFT)\r\n        self.rahmen['ande_ID'].pack(side=LEFT)\r\n\r\n        self.rahmen['ande_change'] = Frame(self.rahmen['ande'])\r\n\r\n        self.rahmen['ande_r'] = Frame(self.rahmen['ande_change'])\r\n        for i in range(len(self.names['schueler'])):\r\n            self.radios['ande-' + self.names['schueler'][i]] = Radiobutton(self.rahmen['ande_r'],\r\n                                                                           text=self.names['schueler'][i],\r\n                                                                           variable=self.vars['ande'], value=i,\r\n                                                                           command=self.radiocom['ande'][i])\r\n            self.radios['ande-' + self.names['schueler'][i]].pack(side=LEFT, fill=X)\r\n        self.radios['ande-Vorname'].select()\r\n        self.rahmen['ande_r'].pack(fill=X)\r\n\r\n        self.rahmen['ande_e'] = Frame(self.rahmen['ande_change'])\r\n        self.entrys['ande_Eandern'] = Entry(self.rahmen['ande_e'])\r\n        self.entrys['ande_Eandern'].pack(fill=X)\r\n        self.rahmen['ande_e'].pack(fill=X)\r\n        self.rahmen['ande_change'].pack(fill=X, padx=4, pady=2)\r\n\r\n        self.rahmen['ande'].pack(fill=X, padx=6, pady=6)\r\n\r\n        self.buttons['ande_B'] = Button(self.fenster['ande'], text=\"ändern\", command=self.callback_ande)\r\n        self.buttons['ande_B'].pack(fill=X, padx=8, pady=6)\r\n\r\n\r\nclass Controller(object):\r\n    def __init__(self):\r\n        self.model = Model()\r\n        self.view = View(self.importieren, self.exportieren, self.beenden, self.J5, self.J6, self.J7, self.J8, self.J9,\r\n                         self.J10, self.J11, self.J12, self.tabelle_update, self.hinzufugen, self.zuordnen, self.ande,\r\n                         self.a1, self.a2, self.a3, self.a4, self.a5, self.a6, self.a7)\r\n        self.wahlen = ('sErst', 'sZweit', 'sDritt')\r\n        self.delimiter = {'imp_s': None, 'imp_p': None, 'exp': None}\r\n        self.dchosen = None\r\n        self.slcsv = 'schuelerliste.csv'\r\n        self.plcsv = 'projektliste.csv'\r\n        self.andernx = \"\"\r\n        self.tabelle()\r\n        self.view.table.bind('<Double-Button-1>', self.treevent)\r\n        self.warten=False\r\n\r\n        if os.path.exists('projektliste.csv') and os.path.exists('schuelerliste.csv') \\\r\n                and not self.model.ausfuhren('SELECT * FROM schueler') \\\r\n                and not self.model.ausfuhren('SELECT * FROM projekte'):\r\n            self.importieren()\r\n\r\n    def treevent(self, event):\r\n        if self.view.table.identify_region(event.x, event.y) == 'cell':\r\n            self.view.schuelerandern()\r\n            self.view.entrys['ande_Eid'].insert(0, event.widget.selection()[0])\r\n\r\n    def zuordnen(self):\r\n        if not self.warten:\r\n            self.warten=True \r\n            self.view.popup_Progressbar()\r\n            self.view.fenster['popup'].update()\r\n            for wahl in self.wahlen:\r\n                self.model.zuordnen(wahl)\r\n                self.view.labels['popup'].step(30)\r\n                self.view.fenster['popup'].update()\r\n            self.model.restzuordnung()\r\n            self.view.labels['popup'].step(9.9999999999)\r\n            self.view.fenster['popup'].update()\r\n            time.sleep(0.5)\r\n            self.tabelle_update()\r\n            self.view.fenster['popup'].destroy()\r\n            self.warten=False\r\n\r\n    def delimOK(self):\r\n        if isinstance(self.dchosen, tuple):\r\n            for d in self.dchosen:\r\n                self.delimiter[d] = self.view.entrys['popup'].get()\r\n        else:\r\n            self.delimiter[self.dchosen] = self.view.entrys['popup'].get()\r\n        if self.delimiter == '':\r\n            showwarning('Angabe ungültig', 'Das angegebene Trennzeichen ist ungültig oder es wurde keines Angegeben!'\r\n                                           '\\nBitte Geben Sie ein anderes Trennzeichen ein!')\r\n            self.view.fenster['popup'].destroy()\r\n            self.delimiterFester(None)\r\n        else:\r\n            self.view.fenster['popup'].destroy()\r\n            self.dchosen = None\r\n\r\n    def delimCanc(self):\r\n        self.view.fenster['popup'].destroy()\r\n\r\n    def delimiterFester(self, d):\r\n        if isinstance(d, tuple):\r\n            self.dchosen = list(self.delimiter.keys())[d[0]], list(self.delimiter.keys())[d[1]]\r\n        elif self.dchosen is None:\r\n            self.dchosen = list(self.delimiter.keys())[d]\r\n        self.view.popup_textentry('Bitte geben Sie das Trennzeichen der CSV-Datei an:', self.delimOK, self.delimCanc)\r\n        while self.dchosen is not None:\r\n            self.view.fenster['popup'].update()\r\n        return True\r\n\r\n    def importieren(self):\r\n        if not isinstance(self.slcsv, str):\r\n            self.slcsv = filedialog.askopenfilename(title=\"Schülerliste importieren\",\r\n                                                    filetypes=((\"CSV Datei\", \"*.csv\"), (\"all files\", \"*.*\")))\r\n            if bool(self.slcsv):  # keine Ausgabe von None bei askopenfile, deswegen als bool interpretieren\r\n                # (nichts=False)\r\n                self.plcsv = filedialog.askopenfilename(title=\"Projektliste importieren\",\r\n                                                        filetypes=((\"CSV Datei\", \"*.csv\"), (\"all files\", \"*.*\")))\r\n        if (self.delimiter['imp_s'], self.delimiter['imp_p']) == (None, None) and bool(self.plcsv):\r\n            if self.delimiterFester((0, 1)):\r\n                self.model.importCSV(self.slcsv, self.plcsv, self.delimiter['imp_s'], self.delimiter['imp_p'])\r\n        if not bool(self.view.table.get_children()):\r\n            self.tabelle()\r\n        else:\r\n            self.tabelle_update()\r\n\r\n    def exportieren(self):\r\n        slcsv = filedialog.asksaveasfile(mode='w', title='Schülerliste exportieren', defaultextension=\".csv\",\r\n                                         initialfile='schuelerl_fertig',\r\n                                         filetypes=((\"CSV Datei\", \"*.csv\"), (\"Txt Datei\", \"*.txt\"),\r\n                                                    (\"all files\", \"*.*\")))\r\n        if slcsv is not None:\r\n            plcsv = filedialog.asksaveasfile(mode='w', title='Projektliste exportieren', defaultextension=\".csv\",\r\n                                             initialfile='projektel_fertig',\r\n                                             filetypes=((\"CSV Datei\", \"*.csv\"), (\"Txt Datei\", \"*.txt\"),\r\n                                                        (\"all files\", \"*.*\")))\r\n            if plcsv is not None:\r\n                if self.delimiterFester(2):\r\n                    self.model.exportCSV(slcsv, plcsv, self.delimiter['exp'])\r\n        else:\r\n            showinfo('Exportiert', \"Die Tabellen wurden in zwei CSV-Dateien mit '\" + self.delimiter['exp'] +\r\n                     \"' als Trennzeichen ausgegeben!\")\r\n\r\n    def beenden(self):\r\n        x = askokcancel(title='Beenden',\r\n                        message='Möchtest du das Programm wirklich beenden?'\r\n                                '\\nNicht abgeschlossene Aktionen könnten zu fehlern führen!')\r\n        if x:\r\n            self.view.destroy()\r\n\r\n    def tabelle(self, fetch=None):\r\n        if fetch is None:\r\n            fetch = self.model.ausgabe('schueler')\r\n        width = [35, 75, 75, 50, 50, 100, 100, 100, 75]\r\n        ml = ['ID']\r\n        for namen in self.view.names['schueler']:\r\n            ml.append(namen)\r\n        ml.append('Zugeordned zu')\r\n        self.view.table['columns'] = ml\r\n        self.view.table['show'] = 'headings'\r\n        for i in range(len(ml)):\r\n            self.view.table.column(ml[i], width=width[i], minwidth=width[i])\r\n        for i in range(len(ml)):\r\n            self.view.table.heading(ml[i], text=ml[i], command=lambda col=i: self.tabelle_sorti(col, False))\r\n        for t in fetch:\r\n            self.view.table.insert('', t[0], t[0], values=t)\r\n        self.view.scrollbar.config(command=self.view.table.yview)\r\n        self.view.table.pack(fill=X)\r\n\r\n    def tabelle_update(self, fetch=None):\r\n        self.view.table.delete(*self.view.table.get_children())\r\n        if fetch is None:\r\n            fetch = self.model.ausgabe('schueler')\r\n        for t in fetch:\r\n            self.view.table.insert('', t[0], t[0], values=t)\r\n\r\n    def tabelle_sorti(self, col, descending):\r\n        data = [(self.view.table.set(tvindex, col), tvindex) for tvindex in self.view.table.get_children('')]\r\n\r\n        try:\r\n            data = [(float(element), tvindex) for element, tvindex in data]\r\n        except ValueError:\r\n            pass\r\n\r\n        data.sort(reverse=descending)\r\n\r\n        for index, (val, k) in enumerate(data):\r\n            self.view.table.move(k, '', index)\r\n\r\n        # reverse sort next time\r\n        self.view.table.heading(col, command=lambda: self.tabelle_sorti(col, not descending))\r\n\r\n    def hinzufugen(self):\r\n        for entry in self.view.entrys:\r\n            self.view.entrys[entry].config(bg='white')\r\n        erst = self.view.entrys[4].get()\r\n        zweit = self.view.entrys[5].get()\r\n        dritt = self.view.entrys[6].get()\r\n        if dritt == \"\":\r\n            dritt = \"33\"\r\n        if zweit == \"\":\r\n            zweit = \"33\"\r\n        if erst == \"\":\r\n            erst = \"33\"\r\n        if self.view.entrys[0].get() != \"\" and self.view.entrys[1].get() != \"\" and \\\r\n                self.view.entrys[2].get() != \"\" and self.view.entrys[3].get() != \"\":\r\n            self.model.einfuegen('schueler', ('sName', 'sVName', 'sJahrg', 'sKla', 'sErst', 'sZweit', 'sDritt'),\r\n                                 (self.view.entrys[1].get(), self.view.entrys[0].get(),\r\n                                  self.view.entrys[2].get(), self.view.entrys[3].get(), erst, zweit, dritt))\r\n            self.view.buttons['hin'].config(bg=\"green\")\r\n            for entry in range(4):\r\n                self.view.entrys[entry].delete(0, END)\r\n            self.view.buttons['hin'].config(bg=\"green\")\r\n            for entry in range(4):\r\n                self.view.entrys[entry].delete(0, END)\r\n                self.view.entrys[entry].config(bg='white')\r\n        else:\r\n            self.view.buttons['hin'].config(bg=\"red\")\r\n            for i in range(4):\r\n                self.view.entrys[i].config(bg='white')\r\n                if self.view.entrys[i].get() == \"\":\r\n                    self.view.entrys[i].config(bg='red')\r\n        self.view.update()\r\n        time.sleep(0.3)\r\n        self.view.buttons['hin'].config(bg=\"white\")\r\n        self.tabelle_update()\r\n\r\n    def ande(self):\r\n        if self.andernx != \"\" and self.view.entrys['ande_Eid'].get() != \"\":\r\n            connection = sqli.connect('pwvwp.db')\r\n            cursor = connection.cursor()\r\n            sql = \"update schueler set \" + self.andernx + \"='\" + str(\r\n                self.view.entrys['ande_Eandern'].get()) + \"' where sID \" \\\r\n                                                          \"like '\" + str(\r\n                self.view.entrys['ande_Eid'].get()) + \"';\"\r\n            cursor.execute(sql)\r\n            connection.commit()\r\n            connection.close()\r\n            self.tabelle_update()\r\n            self.view.fenster['ande'].destroy()\r\n\r\n    def J5(self):\r\n        self.tabelle_update(self.model.jahrgsuch(5))\r\n\r\n    def J6(self):\r\n        self.tabelle_update(self.model.jahrgsuch(6))\r\n\r\n    def J7(self):\r\n        self.tabelle_update(self.model.jahrgsuch(7))\r\n\r\n    def J8(self):\r\n        self.tabelle_update(self.model.jahrgsuch(8))\r\n\r\n    def J9(self):\r\n        self.tabelle_update(self.model.jahrgsuch(9))\r\n\r\n    def J10(self):\r\n        self.tabelle_update(self.model.jahrgsuch(10))\r\n\r\n    def J11(self):\r\n        self.tabelle_update(self.model.jahrgsuch(11))\r\n\r\n    def J12(self):\r\n        self.tabelle_update(self.model.jahrgsuch(12))\r\n\r\n    def a1(self):\r\n        self.andernx = \"sVName\"\r\n\r\n    def a2(self):\r\n        self.andernx = \"sName\"\r\n\r\n    def a3(self):\r\n        self.andernx = \"sJahrg\"\r\n\r\n    def a4(self):\r\n        self.andernx = \"sKla\"\r\n\r\n    def a5(self):\r\n        self.andernx = \"sErst\"\r\n\r\n    def a6(self):\r\n        self.andernx = \"sZweit\"\r\n\r\n    def a7(self):\r\n        self.andernx = \"sDritt\"\r\n\r\n    def unreif(self):\r\n        showwarning('Noch nicht ausgereift', 'Dieser Teil wurde noch nicht Programmiert')\r\n\r\n\r\nc = Controller()\r\nc.view.mainloop()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.py	(revision cba11f5c2d7bed6537c328ae7271be9a6b95dbde)
+++ main.py	(date 1590162835954)
@@ -419,7 +419,7 @@
         self.andernx = ""
         self.tabelle()
         self.view.table.bind('<Double-Button-1>', self.treevent)
-        self.warten=False
+        self.warten = False
 
         if os.path.exists('projektliste.csv') and os.path.exists('schuelerliste.csv') \
                 and not self.model.ausfuhren('SELECT * FROM schueler') \
@@ -433,7 +433,7 @@
 
     def zuordnen(self):
         if not self.warten:
-            self.warten=True 
+            self.warten = True
             self.view.popup_Progressbar()
             self.view.fenster['popup'].update()
             for wahl in self.wahlen:
@@ -446,7 +446,7 @@
             time.sleep(0.5)
             self.tabelle_update()
             self.view.fenster['popup'].destroy()
-            self.warten=False
+            self.warten = False
 
     def delimOK(self):
         if isinstance(self.dchosen, tuple):
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.7\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision cba11f5c2d7bed6537c328ae7271be9a6b95dbde)
+++ .idea/misc.xml	(date 1590162837075)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.7" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8 (Projektwochenverwaltungsprogramm)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/Projektwochenverwaltungsprogramm.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\" />\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.7\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/Projektwochenverwaltungsprogramm.iml	(revision cba11f5c2d7bed6537c328ae7271be9a6b95dbde)
+++ .idea/Projektwochenverwaltungsprogramm.iml	(date 1590162837055)
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.7" jdkType="Python SDK" />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/venv" />
+    </content>
+    <orderEntry type="jdk" jdkName="Python 3.8 (Projektwochenverwaltungsprogramm)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
